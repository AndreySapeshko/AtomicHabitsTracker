# Модели проекта: Atomic Habits Tracker

Этот документ описывает Django-модели, использующиеся в backend проекта.  
Фокус — на структуре данных, валидациях, бизнес-логике и взаимосвязях.

---

# 1. Диаграмма связей моделей

User (CustomUser)
│ 1
│
│ N
Habit
│ 1
│
│ N
HabitInstance

User (CustomUser)
│ 1
│
│ 1
TelegramProfile

yaml
Копировать код

---

# 2. Модель CustomUser (User)

Расположена:  
`atomic_habits_tracker/users/models.py`

> Примечание: В документации используем имя **CustomUser**, хотя в коде модель называется `User`.

## Поля модели:

| Поле | Тип | Описание |
|------|------|----------|
| `email` | EmailField | уникальное поле, используется как логин |
| `password` | CharField | хэшированный пароль |
| `is_active` | Boolean | активность пользователя |
| `is_staff` | Boolean | доступа к админке |
| `date_joined` | DateTime | автоматически устанавливается |

## Особенности:

- Полностью заменяет стандартный Django User.
- Авторизация по email.
- Используется во всех foreign keys.

---

# 3. Модель Habit

Расположена:  
`atomic_habits_tracker/habits/models.py`

Модель отвечает за описание привычки: что делать, когда, где и с какой периодичностью.

## Поля модели:

| Поле | Тип | Описание |
|------|------|----------|
| `user` | FK(CustomUser) | владелец привычки |
| `action` | CharField | текст действия (например: “Drink water”) |
| `place` | CharField | место выполнения |
| `time_of_day` | CharField | утро/день/вечер/ночь |
| `is_pleasant` | Boolean | приятная привычка или полезная |
| `related_pleasant_habit` | FK(Habit, null=True) | приятная привычка, используемая как награда |
| `reward_text` | CharField, null=True | текст награды (если нет pleasant-habit) |
| `periodicity_days` | IntegerField | периодичность: 1,2,3,5,7 |
| `repeat_limit` | IntegerField | срок действия привычки: 21/30/45 |
| `grace_minutes` | IntegerField | время без штрафа |
| `fix_minutes` | IntegerField | максимальное время выполнения |
| `is_public` | Boolean | публичная ли привычка |
| `is_active` | Boolean | архивирована или нет |
| `created_at` | DateTime | Дата создания |

---

# 3.1. Валидации Habit

### ✔ Приятная привычка: `is_pleasant=True`

- `reward_text` ➜ **запрещено**
- `related_pleasant_habit` ➜ **запрещено**

Приятная привычка **сама является наградой** и используется для других привычек.

---

### ✔ Полезная привычка: `is_pleasant=False`

ОБЯЗАТЕЛЬНО должно быть **либо**:

- `reward_text`, **либо**
- `related_pleasant_habit`

НО НЕ ОБА СРАЗУ.

---

### ✔ Пример корректных комбинаций

| Тип привычки | reward_text | related_pleasant_habit | Верно? |
|--------------|-------------|--------------------------|--------|
| приятная | ❌ | ❌ | ✔ |
| приятная | ✔ | ❌ | ❌ |
| полезная | ✔ | ❌ | ✔ |
| полезная | ❌ | ✔ | ✔ |
| полезная | ✔ | ✔ | ❌ |

---

# 3.2. Автоматические поля

`grace_minutes` и `fix_minutes` рассчитываются автоматически:

Пример логики:

- morning → grace=60, fix=120  
- evening → grace=90, fix=180  

(Жёсткие значения можно вынести в settings или constants.)

---

# 4. Модель HabitInstance

Расположена:  
`atomic_habits_tracker/habit_instances/models.py`

Каждый `HabitInstance` — это отдельная задача на конкретную дату.

## Поля модели:

| Поле | Тип | Описание |
|------|------|----------|
| `habit` | FK(Habit) | ссылка на привычку |
| `scheduled_datetime` | DateTime | запланированная дата/время |
| `status` | TextChoice | статус выполнения |
| `completed_at` | DateTime, null=True | время фактического выполнения |

---

# 4. Модель HabitInstance

Расположена:  
`atomic_habits_tracker/habit_instances/models.py`

Каждый `HabitInstance` представляет собой конкретное запланированное действие привычки на определённый день и время.

## Поля модели:

| Поле | Тип | Описание |
|------|------|----------|
| `habit` | FK(Habit) | ссылка на привычку |
| `scheduled_datetime` | DateTime | запланированное время выполнения |
| `status` | TextChoice | статус выполнения инстанса |
| `completed_at` | DateTime, null=True | время фактического выполнения |

---

## 4. Модель HabitInstance

Модель HabitInstance представляет собой отдельную задачу по выполнению привычки на конкретную дату и время.  
Она создаётся автоматически на основе периодичности Habit и служит атомарной единицей статистики.

---

## 4.1. Поля модели HabitInstance

| Поле | Тип | Описание |
|------|------|----------|
| `habit` | FK → Habit | Связанная привычка |
| `scheduled_datetime` | DateTime | Запланированное время выполнения |
| `status` | TextChoice | Текущий статус инстанса |
| `completed_at` | DateTime, null=True | Фактическое время выполнения |

---

## 4.2. Статусы HabitInstance

Статусы определены в классе `HabitInstanceStatus`:

- `scheduled` — инстанс создан заранее, время выполнения ещё не настало  
- `pending` — время выполнения наступило, пользователь может выполнить  
- `completed` — выполнено вовремя, до окончания grace-периода  
- `completed_late` — выполнено после grace, но до окончания fix-периода  
- `missed` — выполнение пропущено, grace-период истёк  
- `fix_expired` — полностью просрочено, истёк даже fix-период  

---

## 4.3. Логика выполнения — метод `mark_completed()`

Алгоритм обработки выполнения:

1. Получить текущее время.  
2. Сравнить его с временными дедлайнами:
   - `scheduled_datetime + grace_minutes`
   - `scheduled_datetime + fix_minutes`
3. Определить статус:
   - если выполнено до grace → `completed`
   - если выполнено после grace, но до fix → `completed_late`
   - если выполнено после fix → `fix_expired`
4. Записать `completed_at`.
5. Инвалидировать кеш статистики привычки.

---

## 4.4. Логика пропуска — метод `mark_failed()`

Применяется автоматически в следующих случаях:

- пользователь не отметил выполнение вовремя  
- Celery-задача определила, что срок прошёл  

Логика:

1. Если сейчас позже grace, но не позже fix → статус `missed`.  
2. Если позже fix → статус `fix_expired`.  
3. Инстанс сохраняется, кеш статистики чистится.

---

## 4.5. Генерация HabitInstance (Celery beat)

Каждый день Celery beat создаёт новые инстансы привычек.  
Общий алгоритм:

1. Получить все активные привычки.  
2. Проверить periodicity_days (1/2/3/5/7).  
3. Создать новый HabitInstance.  
4. Рассчитать дедлайны grace и fix.  
5. Сохранить инстанс.  
6. Отправить уведомление в Redis.  

Telegram-бот, в свою очередь, забирает уведомление и отправляет пользователю push.

---

## 4.6. Использование HabitInstance в Telegram-боте

Через Telegram можно:

- просматривать сегодняшние инстансы  
- выполнять инстанс  
- пропускать  
- отменять выполнение  
- смотреть подробности  

Каждое действие обновляет статус HabitInstance и статистику.

---

## 4.7. HabitInstance и статистика привычек

Инстансы служат основой для расчётов:

- streak (серии подряд)  
- процент выполнения  
- распределение по статусам  
- недельная и месячная диаграмма  
- графики выполнения / пропусков  

Статистика кешируется в Redis.  
Кеш сбрасывается при:

- выполнении инстанса  
- пропуске инстанса  
- изменении Habit  
- удалении Habit  

---

## 5. Модель TelegramProfile

Модель TelegramProfile отвечает за привязку аккаунта Django-пользователя к его Telegram-аккаунту.  
Используется Telegram-ботом для идентификации пользователя и отправки персональных уведомлений.

---

## 5.1. Поля модели TelegramProfile

| Поле | Тип | Описание |
|------|------|----------|
| `user` | FK → CustomUser | Владельц профиля |
| `telegram_id` | BigInteger | Уникальный ID пользователя в Telegram |
| `telegram_username` | CharField | Telegram username пользователя |
| `bind_code` | CharField | Временный код для привязки |
| `is_bound` | Boolean | Статус: привязан или нет |

---

## 5.2. Процесс привязки Telegram

Рабочий процесс:

1. Пользователь переходит в раздел “Profile” на frontend.  
2. Нажимает кнопку «Сгенерировать код привязки».  
3. Backend создаёт новый `bind_code`.  
4. Пользователь открывает Telegram-бота и вводит команду `/bind <код>`.  
5. Бот отправляет код на backend.  
6. Backend ищет профиль по bind_code.  
7. Если найден:
   - сохраняет telegram_id  
   - устанавливает is_bound = True  
   - очищает bind_code  
8. Пользователь получает подтверждение в Telegram.

---

## 5.3. Использование TelegramProfile в проекте

TelegramProfile позволяет:

- получать список привычек в Telegram  
- выполнять привычки с помощью inline-кнопок  
- получать уведомления об инстансах  
- просматривать статистику  
- отвязывать Telegram от аккаунта  

---

## 5.4. Безопасность и ограничения

- `telegram_id` должен быть уникальным.  
- `bind_code` одноразовый — после успешной привязки удаляется.  
- Привязка возможна только для активных пользователей.  
- При отвязке удаляются только Telegram-данные, а не пользовательский аккаунт.  

---

## 6. Взаимосвязь моделей

Проект Atomic Habits Tracker основан на чёткой доменной структуре.  
Ниже — логическая диаграмма связей:

User (CustomUser)
    └── 1:N ─── Habit
                └── 1:N ─── HabitInstance

User (CustomUser)
    └── 1:1 ─── TelegramProfile

---

## 6.1. Связь User → Habit

- Один пользователь может иметь любое количество привычек.  
- У каждой привычки есть владелец (`Habit.user`).  
- При удалении пользователя привычки также удаляются.

---

## 6.2. Связь Habit → HabitInstance

- Каждая привычка генерирует свои инстансы согласно periodicity_days.  
- Инстансы зависят от времени суток, grace и fix дедлайнов.  
- При удалении Habit, все её инстансы удаляются каскадно.

---

## 6.3. Связь User → TelegramProfile

- TelegramProfile — расширение профиля пользователя.  
- Один пользователь может иметь только один TelegramProfile.  
- При удалении пользователя профиль Telegram удаляется.

---

## 6.4. Потоки данных между моделями

### Поток 1: Создание привычки → появление инстансов  
- Пользователь создаёт Habit  
- Celery beat генерирует HabitInstance каждый день  
- Telegram бот уведомляет пользователя  

### Поток 2: Выполнение инстанса  
- Пользователь выполняет привычку в приложении или в Telegram  
- HabitInstance обновляет статус  
- Статистика очищается и пересчитывается  

### Поток 3: Привязка Telegram  
- TelegramProfile связывает Django-пользователя и Telegram-профиль  
- Telegram получает доступ к API от имени пользователя  

---

## 7. Примеры данных моделей (JSON)

Ниже приведены примеры реальных данных, которые возвращает API.

---

## 7.1. Пример Habit

```json
{
  "id": 12,
  "action": "Drink water",
  "place": "Kitchen",
  "time_of_day": "morning",
  "is_pleasant": false,
  "reward_text": "Watch YouTube 5 minutes",
  "related_pleasant_habit": null,
  "periodicity_days": 1,
  "repeat_limit": 21,
  "is_public": true,
  "is_active": true,
  "created_at": "2025-01-31T08:20:10Z"
}
```
## 7.2. Пример HabitInstance
```
{
  "id": 305,
  "habit": 12,
  "scheduled_datetime": "2025-02-01T09:00:00Z",
  "status": "pending",
  "completed_at": null
}
```
## 7.3. Пример TelegramProfile
```
{
  "id": 3,
  "user": 7,
  "telegram_id": 88005553535,
  "telegram_username": "habit_master",
  "is_bound": true
}
```
